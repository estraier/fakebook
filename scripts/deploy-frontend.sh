#!/usr/bin/env bash
set -euo pipefail

# ====== Embedded "production" config (baked into build and start.sh) ======
CFG_NODE_ENV=production
CFG_FRONTEND_PORT=3000           # Next.js listen port
CFG_HOSTNAME=127.0.0.1           # Bind to localhost (Caddy will reverse-proxy)

# Values used at build-time for client bundle (also baked into start.sh)
CFG_NEXT_PUBLIC_BACKEND_API_BASE_URL=/backend
CFG_NEXT_PUBLIC_STORAGE_S3_BUCKET_PREFIX=stgy
CFG_NEXT_PUBLIC_STORAGE_S3_PUBLIC_URL_PREFIX=https://s3.stgy.jp/{bucket}/
# ========================================================================

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OWNER="${DEPLOY_OWNER:-$(id -un)}"
GROUP="${DEPLOY_GROUP:-$(id -gn)}"
TARGET="${DEPLOY_TARGET:-$HOME/stgy-frontend}"

echo "[frontend] Building and staging artifacts..."
cd "$REPO_ROOT"

# Install & build (monorepo)
npm ci --workspaces --include-workspace-root

# Build with required NEXT_PUBLIC_* at build time
export NEXT_PUBLIC_BACKEND_API_BASE_URL="${CFG_NEXT_PUBLIC_BACKEND_API_BASE_URL}"
export NEXT_PUBLIC_STORAGE_S3_BUCKET_PREFIX="${CFG_NEXT_PUBLIC_STORAGE_S3_BUCKET_PREFIX}"
export NEXT_PUBLIC_STORAGE_S3_PUBLIC_URL_PREFIX="${CFG_NEXT_PUBLIC_STORAGE_S3_PUBLIC_URL_PREFIX}"

npm run packages:build
npm run frontend:build

# Prepare target directory
mkdir -p "$TARGET"
mkdir -p "$TARGET/frontend/.next/static" "$TARGET/frontend/public"

# Copy Next.js standalone runtime + assets
rsync -a --delete frontend/.next/standalone/         "$TARGET/"
rsync -a --delete frontend/.next/static/             "$TARGET/frontend/.next/static/"
rsync -a --delete frontend/public/                   "$TARGET/frontend/public/"

# Generate self-contained start.sh (with start/stop/restart/status)
cat > "$TARGET/start.sh" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

APP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$APP_DIR"

# ===== baked-in config (generated by deploy-frontend.sh) =====
export NODE_ENV=__CFG_NODE_ENV__
export NEXT_TELEMETRY_DISABLED=1
export PORT=__CFG_FRONTEND_PORT__
export HOSTNAME=__CFG_HOSTNAME__

# Also export client-facing env for SSR (even though baked at build-time)
export NEXT_PUBLIC_BACKEND_API_BASE_URL="__CFG_NEXT_PUBLIC_BACKEND_API_BASE_URL__"
export NEXT_PUBLIC_STORAGE_S3_BUCKET_PREFIX="__CFG_NEXT_PUBLIC_STORAGE_S3_BUCKET_PREFIX__"
export NEXT_PUBLIC_STORAGE_S3_PUBLIC_URL_PREFIX="__CFG_NEXT_PUBLIC_STORAGE_S3_PUBLIC_URL_PREFIX__"
# ============================================================

PID_DIR="$APP_DIR/run"
LOG_DIR="$APP_DIR/logs"
PID_FILE="$PID_DIR/frontend.pid"

mkdir -p "$PID_DIR" "$LOG_DIR"

find_entry () {
  local ENTRY=""
  local candidates=(
    "server.js" "server.cjs" "server.mjs" "index.js"
    "frontend/server.js" "frontend/server.cjs" "frontend/server.mjs" "frontend/index.js"
  )
  for f in "${candidates[@]}"; do
    [[ -f "$APP_DIR/$f" ]] && { ENTRY="$APP_DIR/$f"; break; }
  done
  if [[ -z "$ENTRY" ]]; then
    ENTRY="$(find "$APP_DIR" -maxdepth 3 -type f \( -name 'server.js' -o -name 'server.cjs' -o -name 'server.mjs' -o -name 'index.js' \) | head -n1 || true)"
  fi
  [[ -z "$ENTRY" ]] && { echo "[error] Next.js server entry not found under: $APP_DIR"; exit 1; }
  printf "%s" "$ENTRY"
}

is_running () {
  [[ -f "$PID_FILE" ]] || return 1
  local pid; pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  [[ -n "${pid:-}" ]] && kill -0 "$pid" 2>/dev/null
}

start_fg () {
  if is_running; then
    echo "[frontend] Already running (PID $(cat "$PID_FILE"))"
    exit 0
  fi
  local ENTRY; ENTRY="$(find_entry)"
  echo "[frontend] Starting (foreground) -> $ENTRY"
  echo $$ > "$PID_FILE" # write our own PID so ExecStop can signal us; we exec node next.
  exec /usr/bin/env node "$ENTRY"
}

start_daemon () {
  if is_running; then
    echo "[frontend] Already running (PID $(cat "$PID_FILE"))"
    exit 0
  fi
  local ENTRY; ENTRY="$(find_entry)"
  echo "[frontend] Starting (daemon) -> $ENTRY"
  nohup /usr/bin/env node "$ENTRY" >"$LOG_DIR/frontend.out.log" 2>"$LOG_DIR/frontend.err.log" &
  echo $! > "$PID_FILE"
  sleep 0.2
  if is_running; then
    echo "[frontend] Started (PID $(cat "$PID_FILE"))"
  else
    echo "[frontend] Failed to start."
    exit 1
  fi
}

stop_proc () {
  if ! is_running; then
    echo "[frontend] Not running"
    rm -f "$PID_FILE"
    return 0
  fi
  local pid; pid="$(cat "$PID_FILE")"
  echo "[frontend] Stopping PID $pid ..."
  kill -TERM "$pid" 2>/dev/null || true
  for i in {1..30}; do
    sleep 0.5
    kill -0 "$pid" 2>/dev/null || { echo "[frontend] Stopped"; rm -f "$PID_FILE"; return 0; }
  done
  echo "[frontend] Forcing kill..."
  kill -KILL "$pid" 2>/dev/null || true
  rm -f "$PID_FILE"
}

status_proc () {
  if is_running; then
    echo "[frontend] Running (PID $(cat "$PID_FILE"))"
  else
    echo "[frontend] Stopped"
    return 3
  fi
}

case "${1:-start}" in
  start)          start_fg ;;
  start-daemon)   start_daemon ;;
  stop)           stop_proc ;;
  restart)        stop_proc ; start_fg ;;
  status)         status_proc ;;
  *)
    echo "Usage: $0 {start|start-daemon|stop|restart|status}"
    exit 2
    ;;
esac
EOF

# Inject config values into start.sh
sed -i \
  -e "s#__CFG_NODE_ENV__#${CFG_NODE_ENV}#g" \
  -e "s#__CFG_FRONTEND_PORT__#${CFG_FRONTEND_PORT}#g" \
  -e "s#__CFG_HOSTNAME__#${CFG_HOSTNAME}#g" \
  -e "s#__CFG_NEXT_PUBLIC_BACKEND_API_BASE_URL__#${CFG_NEXT_PUBLIC_BACKEND_API_BASE_URL}#g" \
  -e "s#__CFG_NEXT_PUBLIC_STORAGE_S3_BUCKET_PREFIX__#${CFG_NEXT_PUBLIC_STORAGE_S3_BUCKET_PREFIX}#g" \
  -e "s#__CFG_NEXT_PUBLIC_STORAGE_S3_PUBLIC_URL_PREFIX__#${CFG_NEXT_PUBLIC_STORAGE_S3_PUBLIC_URL_PREFIX}#g" \
  "$TARGET/start.sh"

chmod +x "$TARGET/start.sh"

# Ownership (best-effort)
if [[ "$(id -un)" != "$OWNER" ]] || [[ "$(id -gn)" != "$GROUP" ]]; then
  if command -v sudo >/dev/null 2>&1; then
    echo "[frontend] Adjusting ownership to ${OWNER}:${GROUP} ..."
    sudo chown -R "$OWNER:$GROUP" "$TARGET"
  else
    echo "[warn] Skipping chown (sudo not available): expected $OWNER:$GROUP -> $TARGET"
  fi
fi

echo "[frontend] Deployment completed: $TARGET"
echo "           To start (foreground): $TARGET/start.sh start"
echo "           To start (daemon):     $TARGET/start.sh start-daemon"
echo "           To stop:               $TARGET/start.sh stop"
echo "           To check status:       $TARGET/start.sh status"
