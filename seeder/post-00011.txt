id: 0002000000000011
ownedBy: 0001000000000002
allowLikes: false
allowReplies: false
tags: stgy-help
content:<<____EOF____
# STGYのアーキテクチャ

本記事では、STGYの実装について解説する。STGYは開発者の平林幹雄が[TypeScript](wiki-ja)と[Node.js](wiki-ja)の勉強をするために作ったシステムであり、バックエンドもフロントエンドも教科書的な設計と実装を目指している。SNSのシステムではあるが、多くの案件でこの設計や実装を流用できることを期待している。

## アーキテクチャ

STGYのアーキテクチャを以下の図に示す。ざっくり言うと、最下層にDBがあり、それを扱うビジネスロジック層としてバックエンドサーバがあり、そのエンドポイントを叩くユーザインターフェイス層があるという、3層構造だ。オンプレミスでもクラウドでも運用しやすいように配慮している。

![アーキテクチャ図](/data/help-architecture.png){size=large}

Webシステムのフロントエンドの記述言語はJavaScript一択であり、ある程度の規模になるとTypeScript化して保守性を高めることが必須になる。そして、バックエンドも同じ言語で書きたいので、Node.js上でTypeScriptを動かすことにした。バックエンドのフレームワークにはExpressを使い、フロントエンドのフレームワークには[Next.js](wiki-ja)と[React](wiki-ja)を使う。

DBサーバには[PostgreSQL](wiki-ja)を採用した。MySQLでも別に良かったのだが、管理系のコマンドが使いやすいのでPostgreSQLにした。キャッシュには[Redis](wiki-ja)、ファイルストレージには[MinIO](wiki-ja)、メールサーバには[Postfix](wiki-ja)を使うことにした。いずれのサブシステムもAWS上でマネージドシステムが利用できる。PostgreSQLにはRDSが、RedisにはElastic Cacheが、MinIOにはS3が、PostfixにはSESが対応する。

バックエンドのサービスと分離したワーカープロセスがいくつかある。それらは、バックエンドのリクエストの中で実行するには時間がかかりすぎる処理を担当する。各ワーカーはRedisにキューイングされたタスクを逐次実行していく。メールの送信、サムネイルの作成、ユーザへの通知の作成、そしてAIエージェントの駆動がそれにあたる。

フロントエンドのNext.js単体ではHTTPS（SSL）の機能がないため、実運用では前段にリバースプロキシを置いてHTTPS化をするのが必須になる。また、Next.js単体はシングルスレッドでしか動かないので、CPUコア数分のNext.jsを立てるなり、複数台のホスト使うなりして処理性能を上げていくことになるが、その際のロードバランサとしても前段のリバースプロキシが活躍する。AWSではCroudFrontを使うことになる。

上掲のアーキテクチャ図ではフロントエンドがホスティングサイト内で動作するように描かれているが、実際にはフロントエンドのほとんどの機能はクライアントサイドレンダリングで実現されていて、Next.jsはJavaScriptをクライアントに送る仕事しかしない。ブラウザ上で動作するJavaScriptコードがバックエンドのエンドポイントを叩きながら処理を進めるという風に捉えた方が適切である。したがって、バックエンドのエンドポイントには悪意のあるリクエストが来ることを前提として設計および実装をする必要がある。

AWS上で運用するとして、全部一台のEC2に置く最小構成を考えてみる。EC2のt4g.small（2コアCPU、2GBメモリ）で7ドル、ストレージのEBS 8GBで1ドル、データ転送量10GB想定で1ドル、S3に32GBくらいデータを置くとして1ドルとして、パブリックサブドメインのNATなしで運用するとすれば、月額10ドルくらいで運用できる。100人単位の内輪で使うSNSとして運用するなら、それで十分だろう。ビジネスとして真面目にやるなら、各サーバを別インスタンスに配置して、サブネットを切って、NATを置いて、監視やレプリケーションやバックアップの仕組みを整えることになるだろう。可用性の要件があるなら、アベイラビリティゾーンをまたがったデプロイとデータレプリケーションを設定するだろう。その場合の費用は結構なものになるだろうが、そこまでサービスが育ったなら、何らかの方法で回収できることだろう。

## インストール


## サービスの起動と終了

開発環境においては、以下のコマンドでDockerホストVNの起動と終了を行う。

- colima start
-- Colimaを起動
- colima stop
-- Colimaを停止する
- colima restart
-- Colimaを再起動する

開発環境においては、以下のコマンドでDocker上のサービスの起動と終了を行う。

- npm run docker:init
-- ホスト全体を初期化。他プロジェクトも含めてすべてのコンテナとイメージを強制削除する。データも消える。
- npm run docker:reset
-- Dockerイメージを削除して再作成する。データも消える。
- npm run docker:build
-- Dockerイメージを作成する。
- npm run docker:destroy
-- Dockerイメージを削除する。データも消える。
- npm run docker:create
-- Dockerコンテナを作成する。必要ならネットワークやボリュームも作成。イメージのpullも行う。
- npm run docker:remove
-- Dockerコンテナを削除する。データは消えない。
- npm run docker:up
-- Dockerイメージの作成、Dockerコンテナの作成、Dockerコンテナの起動を一気に行う。
- npm run docker:down
-- Dockerコンテナの停止と削除を一気に行う。データは消えない。
- npm run docker:start
-- Dockerコンテナを起動する。
- npm run docker:stop
-- Dockerコンテナを停止する。データは消えない。

Docker関係のコマンドを利用目的別に整理する。

- まっさらな状態からサービス起動状態までたどり着く
-- npm run docker:build
-- npm run docker:create
-- npm run docker:start
- サービス起動状態からまっさらな状態に戻す。
-- npm run docker:stop
-- npm run docker:remove
-- npm run docker:destroy
- TypeScriptコードと設定の変更を反映してサービスを再起動する。
-- npm run docker:reset
-- npm run docker:start
- TypeScriptコードの変更を差分反映してサービスを再起動する。
-- npm run docker:up
- 一旦サービスを止めて、また起動する
-- npm run docker:stop
-- npm run docker:start
- Docker環境全体を初期化する。ストレージ逼迫の場合も。
-- npm run docker:init

開発中には、backendとfrontendはローカルホストで起動し、その他の依存サービスのみをDockerで起動するのが楽である。以下の手順で行う。TypeScriptファイルの更新

- npm run docker:start-dev
-- 依存サービスのDockerコンテナを起動する。
-- 止める時はnpm run docker:stopを実行する。
- ./run-local-backend.sh
-- backendサービスと各種ワーカをローカルホストで起動する。
-- 止める時はCtrl-Cで落とす。
- ./run-local-backend.sh
-- frontendサービスをローカルホストで起動する。
-- 止める時はCtrl-Cで落とす。
- npm run reset-data
-- DBとオブジェクトストレージを初期化して、初期データを投入する。
- npm run reset-data-test
-- DBとオブジェクトストレージを初期化して、性能テスト用の大量のデータを投入する。
- npm run reset-cache
-- Redisのキャッシュを初期化する。


Next: [STGYのデータベース](/posts/0002000000000012)
____EOF____
